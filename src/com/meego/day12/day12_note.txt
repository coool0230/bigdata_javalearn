HashMap的内存存储机制
	数组 + 链表
	数组 == 桶的数量
	
HashSet 内部是用HashMap 实现的	
add(s)  -------> put(k,value)----->put(s,+垃圾对象)

hash
------------------------
1.高16位无符号右移16位,与低16位做^(异或)运算
2.得到的整形数值与0xf 做&(且)运算


目的
----------------------------
	1.如果无第一步,name将数值与0xf做&运算,name高16位所表现的特征将被丢失
	如果有第一步,name将原始的哈希码值的高位和低位做了混合,那么在新计算出来的低16位树脂中
	掺杂了高16位的部分特征,高16位的信息也将被保留下来,采用^而不采用& | 的原因:
		采用^运算能更好的保留各部分的特征,不至于像0或者1靠拢
	2.为了保证得到的数值,落在桶的下标之间,得到对应的下标,明确放在哪个桶里
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
作业
--------------------------------
	1.List,Set,Map的区别,以及HashSet和HashMap的关系
	2.